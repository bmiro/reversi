#!/usr/bin/env python3

import copy
import string


X_SIZE = 4
Y_SIZE = 4

WHITE = 'o'
BLACK = 'x'
EMPTY = ' '

DIRECTION_VECTORS = {
    '↑': (0, -1),  '↓': (0, 1),  '←': (-1, 0), '→': (1, 0),
    '↖': (-1, -1), '↙': (-1, 1), '↗': (1, -1), '↘': (1, 1),
}

# State variables
board = []
turn = WHITE


def init_board():

    global board

    line = [] * X_SIZE

    for y in range(Y_SIZE):
        row = []
        for x in range(X_SIZE):
            row.append(EMPTY)
        board.append(row)

    board[int(X_SIZE / 2 - 1)][int(Y_SIZE / 2 - 1)] = WHITE
    board[int(X_SIZE / 2)][int(Y_SIZE / 2 - 1)] = BLACK
    board[int(X_SIZE / 2 - 1)][int(Y_SIZE / 2)] = BLACK
    board[int(X_SIZE / 2)][int(Y_SIZE / 2)] = WHITE


def print_board(board_to_print=board):

    print("  " + "".join([str(x) for x in range(1, len(board_to_print[0]) + 1)]))
    print("  " + '_' * len(board_to_print))

    i = 0
    for y in range(len(board_to_print)):
        print(string.ascii_lowercase[y] + '|', end='')
        for x in range(len(board_to_print[y])):
            cell = board_to_print[y][x] if board_to_print[y][x] != 0 else ' '
            print(cell, end='')
        print()


def valid_move_input(x, y, candidate_positions=None):

    if x > len(board[0]) - 1:
        print("X axis overflow")
        return False

    if y > len(board) - 1:
        print("Y axis overflow")
        return False

    if board[y][x] != EMPTY:
        print("Cell already full")
        return False

    if candidate_positions and (x, y) not in candidate_positions:
        print("No flips on this position")
        return False

    return True


def translate_move(move):
    x = int(move[1]) - 1
    y = int(string.ascii_lowercase.index(move[0]))

    return (x, y)


def translate_position(x, y):
    return string.ascii_lowercase[y] + str(x + 1)


def flip(positions):
    global board

    for x, y in positions:
        print("Flipping {}".format(translate_position(x, y)))
        board[y][x] = WHITE if board[y][x] == BLACK else BLACK


def estimate_flips():

    estimated_flips = {}
    for y_pos in range(Y_SIZE):
        for x_pos in range(X_SIZE):
            if board[y_pos][x_pos] in (BLACK, WHITE):
                continue

            for op, vect in DIRECTION_VECTORS.items():

                flip_candidates = []
                ally_found = False

                x = x_pos + vect[0]
                y = y_pos + vect[1]
                while x >= 0 and x < X_SIZE and y >= 0 and y < Y_SIZE:
                    if board[y][x] == EMPTY:
                        break

                    if board[y][x] == turn:
                        ally_found = True
                        break

                    flip_candidates.append((x, y))

                    x += vect[0]
                    y += vect[1]

                if ally_found and len(flip_candidates):
                    estimated_flips.setdefault(
                        (x_pos, y_pos),
                        0
                    )

                    estimated_flips[(x_pos, y_pos)] += len(flip_candidates)

    return estimated_flips


def move(candidate_positions):

    global turn
    global board

    move_canidate = input("Moves {}: ".format(turn))

    (x_pos, y_pos) = translate_move(move_canidate)
    while not valid_move_input(x_pos, y_pos, candidate_positions):
        print("Invalid move")
        move_canidate = input("Moves {}: ".format(turn))
        (x_pos, y_pos) = translate_move(move_canidate)

    for op, vect in DIRECTION_VECTORS.items():

        flip_candidates = []
        ally_found = False

        x = x_pos + vect[0]
        y = y_pos + vect[1]
        while x >= 0 and x < X_SIZE and y >= 0 and y < Y_SIZE:

#            print("{} testing: {}".format(op, translate_position(x, y)))
            if board[y][x] == EMPTY:
                break

            if board[y][x] == turn:
                ally_found = True
                break

            # Is not EMPTY nor ally so is a candidate to flip if
            # an ally is found later.
            flip_candidates.append((x, y))

            x += vect[0]
            y += vect[1]

        if ally_found:
            flip(flip_candidates)

    board[y_pos][x_pos] = turn


if __name__ ==  '__main__':
    init_board()
    print_board()

    empty_cells = X_SIZE * Y_SIZE - 4
    while empty_cells:
        candidate_positions = estimate_flips().keys()
        move(candidate_positions)
        print_board()
        turn = WHITE if turn == BLACK else BLACK
        empty_cells -= 1


    score = {
        WHITE: 0,
        BLACK: 0,
    }
    for y in range(Y_SIZE):
        for x in range(X_SIZE):
            score[board[y][x]] += 1

    winner = sorted(score.items(), key=lambda item: item[1], reverse=True)[0][0]

    print("The winner is: {}".format(winner.upper()))
